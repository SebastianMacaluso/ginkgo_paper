%\documentclass[aps,onecolumn,preprint,superscriptaddress,nofootinbib,floats]{revtex4}
%\usepackage{graphicx}

\documentclass[12pt]{article}

\usepackage{amsmath}
\usepackage[linesnumbered,ruled,noline,noend]{algorithm2e}

%\usepackage[linesnumbered,noline,noend]{algorithm2e}
%\usepackage{amsmath}

\SetNlSty{}{}{}

\let\oldnl\nl% Store \nl in \oldnl
\newcommand\nonl{%
  \renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line



\def\beq{\begin{equation}}
\def\eeq{\end{equation}}


\usepackage{amsmath,amssymb,graphicx,multirow,xspace,slashed}
\usepackage[colorlinks=true,urlcolor=blue,anchorcolor=blue,citecolor=blue,filecolor=blue,linkcolor=blue,menucolor=blue,pagecolor=blue]{hyperref}


\usepackage{floatrow}
% Table float box with bottom caption, box width adjusted to content
\newfloatcommand{capbtabbox}{table}[][\FBwidth]


\usepackage[font=footnotesize,labelfont=bf]{caption}

\newcommand*\myat{{\fontfamily{ptm}\selectfont @}}

%\usepackage[notref]{showkeys}
\usepackage{lineno}

\allowdisplaybreaks
% \bibliographystyle{JHEP}
\bibliographystyle{utphys}
%% Some suggested packages, as needed:
% \usepackage{natbib} % has a nice set of citation styles and commands
%     % \bibliographystyle{plainnat}
%     \bibliographystyle{utphys}
%     \renewcommand{\bibsection}{\subsubsection*{References}}

\addtolength{\oddsidemargin}{-.4in}
\addtolength{\evensidemargin}{-.4in}
\addtolength{\textwidth}{0.8in}
\addtolength{\topmargin}{-.6in}
\addtolength{\textheight}{1in}
%\addtolength{\footskip}{0.3in}
\renewcommand{\baselinestretch}{1.2}

\long\def\symbolfootnote[#1]#2{\begingroup%
\def\thefootnote{\fnsymbol{footnote}}\footnote[#1]{#2}\endgroup}

\renewcommand{\textfraction}{0}
\renewcommand{\topfraction}{0.95}


\newcommand{\newc}{\newcommand}
\newc{\gsim}{\lower.7ex\hbox{$\;\stackrel{\textstyle>}{\sim}\;$}}
\newc{\lsim}{\lower.7ex\hbox{$\;\stackrel{\textstyle<}{\sim}\;$}}
\newc{\gev}{\,{\rm GeV}}
\newc{\mev}{\,{\rm MeV}}
\newc{\ev}{\,{\rm eV}}
\newc{\kev}{\,{\rm keV}}
\newc{\tev}{\,{\rm TeV}}

\newcommand{\ifb}{\,\mathrm{fb}^{-1}}
\newcommand{\ipb}{\,\mathrm{pb}^{-1}}
\renewcommand*\descriptionlabel[1]{\hspace\labelsep\normalfont #1}

\def\ln{\mathop{\rm ln}}
\def\tr{\mathop{\rm tr}}
\def\Tr{\mathop{\rm Tr}}
\def\Im{\mathop{\rm Im}}
\def\Re{\mathop{\rm Re}}
\def\bR{\mathop{\bf R}}
\def\bC{\mathop{\bf C}}
\def\lie{\mathop{\hbox{\it\$}}} %pound sterling
\newc{\mz}{M_Z}
\newc{\mpl}{M_*}
\newc{\mw}{m_{\rm weak}}
\newc{\nr}[1]{N^c_R{}_{#1}}

%\renewcommand{\phi}{\varphi}

%indices and other greek stuff
\renewcommand{\a}{\alpha}
\newcommand{\da}{{\dot \alpha}}
\renewcommand{\b}{\beta}
\newcommand{\db}{{\dot\beta}}
\newcommand{\g}{\gamma}
\newcommand{\dg}{{\dot\gamma}}
\renewcommand{\d}{\delta}
\newcommand{\dd}{{\dot\delta}}
\newcommand{\m}{\mu}
\newcommand{\n}{\nu}
\newcommand{\e}{\epsilon}
\newcommand{\s}{\sigma} 
\renewcommand{\r}{\rho}
\newcommand{\bs}{{\bar\sigma}}
\renewcommand{\l}{\lambda}
\renewcommand{\L}{\Lambda}
\renewcommand{\k}{\kappa}
\renewcommand{\th}{\theta}
\newcommand{\thb}{{\bar\theta}}
\newcommand{\D}{\Delta}
\newcommand{\B}{\bar B_\mu}
\newcommand{\cA}{c_{A_{u,d}}}
\newcommand{\cH}{c_{m_{u,d}}}
\renewcommand{\dag}{\dagger}
\newcommand{\bra}{\langle}
\newcommand{\ket}{\rangle}
\newcommand{\Q}{\bar Q}
\renewcommand{\O}{O}

\newcommand{\CM}{{\mathcal M}}

%%%%%%%%%%%%%%%%%%%%%%%% special abrev's %%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\mhu}{{\hat m_{H_u}}}
\newcommand{\mhd}{{\hat m_{H_d}}}
\newcommand{\mhud}{{\hat m_{H_{u,d}}}}


%%%%%%%%%%%%%%%%%%%%%%% latex eqn abrev's %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\def\beq{\begin{equation}}
\def\eeq{\end{equation}}
\newcommand{\bea}{\begin{eqnarray}\begin{aligned}}
\newcommand{\eea}{\end{aligned}\end{eqnarray}}
\def\bitem{\begin{itemize}}
\def\eitem{\end{itemize}}
%
%
%%%%%%%%%%%%%%%%%%%%%%% common abrev's %%%%%%%%%%%%%%%%%
%
%

\newc{\ie}{{\it i.e.}}          \newc{\etal}{{\it et al.}}
\newc{\eg}{{\it e.g.}}          \newc{\etc}{{\it etc.}}
\newc{\cf}{{\it c.f.}}
\newcommand{\kahler}{K\"{a}hler }

\newcommand{\lang}{\mathcal{L}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\CO}{O}
\newcommand{\half}{\frac{1}{2}}


%\renewcommand{\epvar}{\varepsilon}
%\renewcommand{\phi}{\varphi}
\renewcommand{\topfraction}{0.85}
\renewcommand{\textfraction}{0.1}
\renewcommand{\floatpagefraction}{0.75}

%number equations by section
 %\numberwithin{equation}{section}

%toc depth
\setcounter{tocdepth}{2}

%Begin special definitions for Instructions file
\newcommand{\ttbs}{\char'134}%\backslash for \tt
\newcommand\fverb{\setbox\fverbbox=\hbox\bgroup\verb}
\newcommand\fverbdo{\egroup\medskip\noindent%
            \fbox{\unhbox\fverbbox}\ }
\newcommand\fverbit{\egroup\item[\fbox{\unhbox\fverbbox}]}
\newbox\fverbbox
\newcommand{\jhepname}{JHEP}
%end


\renewcommand{\arraystretch}{1.3}

%\usepackage[usenames,dvipsnames]{xcolor}


\usepackage{tikz}

\newcommand{\shrug}[1][]{%
\begin{tikzpicture}[baseline,x=0.8\ht\strutbox,y=0.8\ht\strutbox,line width=0.125ex,#1]
\def\arm{(-2.5,0.95) to (-2,0.95) (-1.9,1) to (-1.5,0) (-1.35,0) to (-0.8,0)};
\draw \arm;
\draw[xscale=-1] \arm;
\def\headpart{(0.6,0) arc[start angle=-40, end angle=40,x radius=0.6,y radius=0.8]};
\draw \headpart;
\draw[xscale=-1] \headpart;
\def\eye{(-0.075,0.15) .. controls (0.02,0) .. (0.075,-0.15)};
\draw[shift={(-0.3,0.8)}] \eye;
\draw[shift={(0,0.85)}] \eye;
% draw mouth
\draw (-0.1,0.2) to [out=15,in=-100] (0.4,0.95); 
\end{tikzpicture}}



\newcommand{\MYhref}[3][blue]{\href{#2}{\color{#1}{#3}}}%

\begin{document}
%
%\title{Toy Generative Model for Jets}
%\author{Kyle Cranmer, Sebastian Macaluso and Duccio Pappadopulo}
%\maketitle


\begin{center}

\vskip 1cm
{\Large \bf Toy Generative Model for Jets}

\vskip 1.0cm
{\large $\text{Kyle Cranmer}^1$, $\text{Sebastian Macaluso}^1$ and $\text{Duccio Pappadopulo}^2$}
\vskip 0.6cm
{\small \it 1 Center for Cosmology and Particle Physics $\&$ Center for Data Science, New York University, USA} \\
{\small \it 2 Bloomberg LP, New York, NY 10022, USA. (Work done before joining Bloomberg LP.)}
\vskip 2.0cm

\end{center}




\section{Introduction}

In this notes, we provide a standalone description of a generative model to aid in machine learning (ML) research for jet physics. The motivation is to build a model that has a tractable likelihood, and is as simple and easy to describe as possible but at the same time captures the essential ingredients of parton shower generators in full physics simulations.  The aim is for the model to have a python implementation with few software dependencies.

Parton shower generators are software tools that encode a physics model for the simulation of jets that are produced at colliders, e.g. the Large Hadron Collider at CERN.
Jets are a collimated spray of energetic charged and neutral particles. Parton showers generate the particle content of a jet, going through a cascade process, starting from an initial unstable particle. In this description, there is a recursive algorithm that produces binary splittings of an unstable parent particle into two children particles, and a stopping rule. Thus, starting from the initial unstable particle, successive splittings are implemented until all the particles are stable (i.e. the stopping rule is satisfied for each of the final particles). We refer to this final particles as the jet constituents.

As a result of this {\it showering process}, there could be many latent paths that may lead to a specific jet (i.e. the set of constituents). Thus, it is natural and straightforward to represent a jet and the particular showering path that gave rise to it as a binary tree, where the inner nodes represent each of the unstable particles and the leaves represent the jet constituents.  


% =====================================================
\vspace{0.6cm}
\section{Model description}

Our model implements a recursive algorithm to generate a binary tree, whose leaves are the jet constituents. Jet constituents in full physics simulations are described in terms of a 4 dimensional vector that specifies their energy $E$ and spatial momentum $\vec{p}$, which determines the direction of motion. 
We want our model to represent the following features:
%There is a set of physics features that we want our model to represent, and they are described as follows:
\begin{itemize}
\item Momentum conservation: the total momentum of the jet (the momentum of the root of the tree) is obtained from adding the momentum of all of its constituents.

\item Running of the splitting scale: each splitting is characterized by a scale $t$ that decreases when evolving down the tree from root to leaves. In particular $t$ is the invariant mass squared, $t = m^2$.




% and $p_{\text{T}}$ is the momentum transverse to some fixed direction. 
%Also, $\alpha=\{-1,0,1\}$ defines the $\{\text{anti-kt, CA and kt}\}$ clustering algorithms respectively. 

\end{itemize}

We also want our model to lead to a natural analogue of the generalized $k_t$ clustering algorithms for the generated jets. These algorithms are characterized by

\begin{itemize}
\item Permutation invariance: the jet momentum should be invariant with respect to the order in which we cluster its constituents.

\item Distance measure: the angular separation between two jet constituents is typically used as a distance measure among them. In particular, traditional jet clustering algorithms are based on a measure given by 
$d_{ij} \propto  \Delta R_{ij}^2$
where $\Delta R_{ij}$ is the angular separation between two particles.

\end{itemize} 


We build our model as follows. During the generative process, starting from the root of the tree, each parent node is split, generating a left (L) and a right (R) child. At each splitting we sample squared invariant masses for the children, $t_L, t_R$ from a decaying exponential. We require the constraint $\sqrt{t_L} + \sqrt{t_R} < \sqrt{t_P}$, where $\sqrt{t_P}$ is the parent mass. Then we implement a 2-body decay in the parent center-of-mass frame. The children direction is obtained by uniformly sampling a unit vector on the 2-sphere (in the parent center-of-mass frame the children move in opposite directions). Finally, we apply a Lorentz boost to the lab frame, to obtain the 4 dimensional vector $p_{\mu}=(E, p_x, p_y, p_z) $ that characterizes each node.
This prescription ensures {\it momentum conservation} and {\it permutation invariance}.
We show in Fig.~\ref{fig:1DTree} a tree visualization plot of a sample jet generated with our model.
% Jet constituents are 4-vectors now and boosts are well defined.
% Differences wrt a full parton shower simulation:
% - Final state particles are still off-shell in Ginkgo
% - Likelihood still follows a decaying exponential instead of QCD splitting functions+Sudakov factors. 
% - Angular ordering not explicitly imposed



\begin{figure*}
{
  \includegraphics[width=\linewidth]{figs/figTruth_jet9_invM.pdf}
%  \includegraphics[width=0.5\linewidth]{plots/figTruthTruth_fullpath_jet2}
}
\caption{\small{Tree visualization of a sample jet generated with our model that represents a W boson jet, as described in section \ref{Heavy resonance vs QCD like jet}. We show the values of $p_T =\sqrt{ p_x^2 +p_y^2}$ for each node and their mass. The horizontal ordering of the leaves corresponds to the order in which the leaves are accessed when traversing the tree (and is not related to the particle momentum $\vec{p}$).
}}
\label{fig:1DTree}
\end{figure*}

%%-------------
\subsection{Generative process}\label{Generatiion}

In this section, we describe the implementation of the generative process, which depends on the following input parameters:
\begin{itemize}

\item $p_0^\mu$: 4-momentum of the jet. This will be the input value for the root node of the tree.
\item $t_0$: initial mass squared. 
\item $t_\text{cut}$: cut-off mass squared to stop the showering process. 
\item $\lambda$: decaying rate for the exponential distribution.

\end{itemize}

Next, we describe the splitting of a node as follows:
\begin{enumerate}

\item Draw $ t_{\text{L}}$ and  $t_{\text{R}}$ from an exponential distribution as follows,
\bea \label{eq:exponential1}
t_L \sim f(t | \lambda, t_{\text{P}})=\frac{1}{1-e^{- \lambda}} \frac{\lambda}{t_{\text{P}}} e^{- \frac{\lambda}{ t_{\text{P}}} t} 
\eea
\bea \label{eq:exponential2}
t_R \sim f(t | \lambda, (\sqrt{t_{\text{P}}}-\sqrt{t_L})^2)= \frac{1}{1-e^{- \lambda}} \frac{\lambda}{ (\sqrt{t_{\text{P}}}-\sqrt{t_L})^2} e^{- \frac{\lambda}{ (\sqrt{t_{\text{P}}}-\sqrt{t_L})^2} t} 
\eea
and  define $m_L=\sqrt{t_\text{L}}$ and $m_R=\sqrt{t_\text{R}}$. We apply a veto on sampled values where $t_L  \geqslant t_{\text{P}}$ and $t_R \geqslant (\sqrt{t_{\text{P}}}-\sqrt{t_L})^2$. For inference, given two particles, we assign $t_L \rightarrow \text{max}\{t_L, t_R\} $ and $t_R \rightarrow \text{min}\{t_L, t_R\} $.


\item Compute a 2-body decay in the parent rest frame, where its momentum is $p^\mu_p=p^\mu_{\text{L}}+p^\mu_{\text{R}}=(\sqrt{s}, 0, 0, 0)$. From requiring 4-momentum conservation, the children energies are given by
\bea
E_{\text{L}}=\frac{\sqrt{s}}{2}\bigg(1+\frac{t_{\text{L}}}{s}-\frac{t_{\text{R}}}{s} \bigg) \\
E_{\text{R}}=\frac{\sqrt{s}}{2}\bigg(1+\frac{t_{\text{R}}}{s}-\frac{t_{\text{L}}}{s} \bigg)
\eea
and the magnitude of their 3-momentum by
\bea\label{eq:Prestframe}
|\vec{p}| =\frac{\sqrt{s}}{2} \bar{\beta}=\frac{\sqrt{s}}{2} \sqrt{1-\frac{2 (t_{\text{L}}+t_{\text{R}})}{s}+\frac{(t_{\text{L}}-t_{\text{R}})^2}{s^2}}
\eea
Thus, in the parent rest frame, the left and right child momentum is given by $p^\mu_\text{L}=(E_{\text{L}},\vec{p})$ and $p^\mu_\text{R}=(E_{\text{R}},-\vec{p})$. 

\item Apply a Lorentz boost to each of the children, with $\gamma=\frac{E_p}{\sqrt{t_P}}$ and $\gamma \beta = |\vec{p}_p|/\sqrt{t_P}$. 

\item If $t_{\text{L}}$ ($t_{R}$) is greater than  $t_\text{cut}$ repeat the process.

\end{enumerate}





%\subsubsection{Splitting of a node}
%Given a parent node with momentum $\vec{p}_\text{p}$, and a scalar value $\Delta_{\text{p}}$ that sets the scale of the splitting, we define the splitting function as follows:
%\begin{enumerate}
%
%\item We draw a value $\phi_\text{p}$ for the angle in the (y,z) plane, from a uniform distribution in the range $\{0,2\pi\}$ and define
%\bea\label{eq:Deltavec}
%\vec{\Delta}_\text{p}= \Delta_\text{p}\,\,(\sin\phi_\text{p},\cos\phi_\text{p})
%\eea 
%
%\item We obtain the L,R children nodes momentum,
%\bea\label{eq:pLR}
%\vec{p}_\text{L}= \frac{1}{2} \vec{p}_\text{p} - \vec{\Delta}_\text{p}  \\
%\vec{p}_\text{R}= \frac{1}{2} \vec{p}_\text{p} +\vec{\Delta}_\text{p}
%\eea
%
%\item We separately draw $ \Delta_{\text{L}}$ and  $\Delta_{\text{R}}$ from an exponential distribution 
%\bea \label{eq:exponential}
%f(\Delta | \lambda, \Delta_{\text{p}})=\frac{\lambda}{ \Delta_{\text{p}}} e^{- \frac{\lambda}{ \Delta_{\text{p}}} \Delta} 
%\eea
%%
%%and generate
%%\bea
%%\Delta_\text{L} &= \Delta_\text{p} \,\, r_\text{L}\\
%%\Delta_\text{R} &= \Delta_\text{p} \,\, r_\text{R}
%%\eea
%
%\end{enumerate}
%
%
%
%We start the showering process with the root node as the parent node and build the jet binary tree recursively as follows:
%\begin{itemize}
%
%\item We split the parent node, and get $\vec{p}_\text{L}$, $\vec{p}_\text{R}$, $\Delta_\text{L}$, $\Delta_\text{R}$.
%
%\item If $\Delta_\text{L/R} > \Delta_\text{cut}$, we promote the L/R node to a parent node (i.e. we promote $\vec{p}_\text{L/R}$ to $\vec{p}_\text{p}$ and $\Delta_\text{L/R}$ to $\Delta_\text{p}$), and split again.
%
%\end{itemize}

The algorithm is outlined in more detail in Algorithm 1. After running the algorithm, the final binary tree for the jet is obtained.
%structure ($tree$) and momentum of each node ($content$) are obtained.

\begin{algorithm}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}

    function NodeProcessing $(p^\mu_{\text{p}}, t_\text{P}, t_\text{cut}, \lambda, \text{tree})$\\
    \Input{parent momentum $\vec{p}_{\text{p}}$, parent mass squared $t_\text{p}$, cut-off mass squared $t_\text{cut}$, rate for the exponential distribution $\lambda$, binary tree $tree$}
    \Indp
%    idx = length of tree modulo 2\\
    Add parent node to tree. \\
%    Append node momentum $\vec{p}_{\text{p}}$ to content list.\\
    \If{$t_\text{p} > t_\text{cut}$}
      {
      	Sample $t_L$ and $t_R$ from the decaying exponential distribution.\\
	Sample a unit vector from a uniform distribution over the 2-sphere.\\
	Compute the 2-body decay of the parent node in the parent rest frame.\\
	Apply a Lorentz boost to the lab frame to each child.\\
	NodeProcessing $(p^\mu_{\text{p}}, t_\text{L}, t_\text{cut}, \lambda, \text{tree})$\\
	NodeProcessing $(p^\mu_{\text{p}}, t_\text{R}, t_\text{cut}, \lambda, \text{tree})$\\
%      	draw $\phi$ from uniform distribution in $\{0,2\pi\}$\\
%	$\vec{\Delta}_\text{p}= \Delta_\text{p}\,\,(\sin\phi_\text{p},\cos\phi_\text{p})$\\
%      	$\vec{p}_\text{L}= \frac{1}{2} \vec{p}_\text{p} - \vec{\Delta}_\text{p}$  \\
%        $\vec{p}_\text{R}= \frac{1}{2} \vec{p}_\text{p} +\vec{\Delta}_\text{p}$\\
%        draw $\Delta_\text{L}$, $\Delta_\text{R}$ from the exponential distribution in Eq.~\ref{eq:exponential}.\\
%	NodeProcessing $(\vec{p}_{\text{L}}, \Delta_\text{L}, \Delta_\text{cut}, \lambda, \text{tree})$\\
%	NodeProcessing $(\vec{p}_{\text{R}}, \Delta_\text{R}, \Delta_\text{cut}, \lambda, \text{tree})$\\
      }
    \caption{Toy Parton Shower Generator}
\end{algorithm}






%\begin{algorithm}
%    \SetKwInOut{Input}{Input}
%    \SetKwInOut{Output}{Output}
%
%    function NodeProcessing $(\vec{p}_{\text{p}},\text{idx}_{\text{gp}}, \Delta_\text{p}, \Delta_\text{cut}, \lambda, \text{tree}, \text{content})$\\
%    \Input{parent momentum $\vec{p}_{\text{p}}$, grandparent index $\text{idx}_\text{gp}$, parent splitting scale $\Delta_\text{p}$, cut-off scale $\Delta_\text{cut}$, rate for the exponential distribution $\lambda$, list with tree structure $tree$, list with nodes momentum $content$}
%    \Indp
%    idx = length of tree modulo 2\\
%    Insert in tree list node idx at location $[\text{idx}_\text{gp},0]$ ($[\text{idx}_\text{gp},1]$) if node is L (R). \\
%    Append node momentum $\vec{p}_{\text{p}}$ in content list.\\
%    \If{$\Delta_\text{p} > \Delta_\text{cut}$}
%      {
%      	draw $\phi$ from uniform distribution in $\{0,2\pi\}$\\
%	$\vec{\Delta}_\text{p}= \Delta_\text{p}\,\,(\sin\phi_\text{p},\cos\phi_\text{p})$\\
%      	$\vec{p}_\text{L}= \frac{1}{2} \vec{p}_\text{p} - \vec{\Delta}_\text{p}$  \\
%        $\vec{p}_\text{R}= \frac{1}{2} \vec{p}_\text{p} +\vec{\Delta}_\text{p}$\\
%        draw $r_L$, $r_R$ from the exponential distribution in Eq.~\ref{eq:exponential}.\\
%        $\Delta_\text{L} = \Delta_\text{p} \,\, r_\text{L}$\\
%	$\Delta_\text{R} = \Delta_\text{p} \,\, r_\text{R}$\\
%	NodeProcessing $(\vec{p}_{\text{L}},\text{idx}, \Delta_\text{L}, \Delta_\text{cut}, \lambda, \text{tree}, \text{content})$\\
%	NodeProcessing $(\vec{p}_{\text{R}},\text{idx}, \Delta_\text{R}, \Delta_\text{cut}, \lambda, \text{tree}, \text{content})$\\
%      }
%    \caption{Toy Parton Shower Generator}
%\end{algorithm}


%%-------------
\subsubsection{Heavy resonance vs QCD like jet}\label{Heavy resonance vs QCD like jet}

To model a jet coming from a heavy resonance X decay, e.g. a W boson jet, we introduce two values for the decaying constant $\lambda_X, \, \lambda$. This way we model the first splitting (the root node splitting) with $\lambda_X$ and then use $\lambda$ for the remaining shower process. We also set $t_\text{root} = m_X^2$.

To model a QCD like jet, we use a single value for $\lambda$ for the whole process.

%%-------------

\subsubsection{Likelihood reconstruction}

For each pair of nodes in a tree, we reconstruct the parent momentum by adding the children momentum. 
\bea
{p}^\mu_\text{p} &= p^\mu_\text{L}+ p^\mu_\text{R}
\eea


Given each 4-momentum vector $p^\mu = (E, \vec{p}\,)$, we find the invariant mass squared as $t= E^2-|\vec{p}\,|^2$. 
Then we identify $t_L$ with the child with greater invariant mass and define
\bea\label{parentmasses}
t_\text{p}^L & \equiv t_{\text{P}}= (p_\text{p}^\mu)^2 = E_\text{p}^2 - |\vec{p}\,|_\text{p}^{\,2}\\
t_\text{p}^R & = (\sqrt{t_{\text{P}}}-\sqrt{t_L})^2
\eea

Next we introduce the cumulative density function $F_s^i(t_{\text{cut}},t_{\text{p}}^i)$ for a given shower branch to stop\footnote{If $t_\text{p}^R \leq t_{\text{cut}}$ then $F_s^R=1$.} with $i \in \{L,R\}$, i.e. the probability of having sampled a value of $t < t_{\text{cut}}$. Now, we can define the likelihood of a parent going to $t_L$ and $t_R$ (from Eqs. \ref{eq:exponential1} and \ref{eq:exponential2}) as
\begin{eqnarray}
\ell(t_i, \lambda,t_\text{cut},  t_{\text{p}}^i) =
\left\{    
\begin{matrix}
f(t_i | \lambda, t_{\text{p}}^i)\,\,\,\,\,\,\,\, & t_{\text{p}}^i>t_\text{cut}\\
F_s^i(t_{\text{cut}}, t_{\text{p}}^i) \,\,\,\,\,\,\,\,& t_{\text{p}}^i\leq t_\text{cut} \\
\end{matrix}\right.
\end{eqnarray}
for $i \in \{L,R\}$.
Finally, we add a factor that considers the probability of splitting given by $(1-F_s(t_{\text{cut}}, t_{\text{P}}))$ and the likelihood from sampling uniformly over the two-sphere as $\frac{1}{4 \pi}$. Thus, putting it all together, we obtain the splitting likelihood of a parent node into a L and R children as\footnote{Note that in \cite{Cranmer:2021gdt, Greenberg:2021nrg, Brehmer:2020brs, Greenberg:2020heb}  we used a different objective function for the likelihood. The only difference is that it did not include the probability of splitting  $(1-F_s(t_{\text{cut}},t_{\text{P}}))$.}
\beq
\mathcal{F}(t_L,t_R, \lambda,t_{\text{cut}}) = \frac{1}{4 \pi} (1-F_s(t_{\text{cut}},t_{\text{P}})) \,\, \ell(t_L, \lambda,t_\text{cut},  t_{\text{p}}^L) \,\, \ell(t_R, \lambda,t_\text{cut},  t_{\text{p}}^R) 
\eeq
% For the leaves we 

%\subsubsection{Reconstruct $\{\vec{p}_\text{p}$, $\Delta_{\text{p}}$, $\phi_{\text{p}}$, $r_L$, $r_R\}$ from  $\{\Delta_L$, $\Delta_R$, $\vec{p}_\text{L}$, $ \vec{p}_\text{R}\}$ }
%
%Next, we show how to reconstruct $\{\vec{p}_\text{p}$, $\Delta_{\text{p}}$, $\phi_{\text{p}}$, $r_L$, $r_R\}$ from a bottom-up approach for each splitting. From  $\{\Delta_L$, $\Delta_R$, $\vec{p}_\text{L}$, $ \vec{p}_\text{R}\}$ we can obtain
%\bea
%{p}^\mu_\text{p} &= p^\mu_\text{L}+ p^\mu_\text{R}\\
%\vec{\Delta}_\text{p} &= \frac{1}{2} (\vec{p}_\text{R} - \vec{p}_\text{L})
%\eea
%which can be used to calculate
%\bea
%\Delta_\text{p} &= | \vec{ \Delta}_\text{p} |\\
%\phi_{\text{p}} &=\tan^{-1}\frac{(\Delta_\text{p})_y}{(\Delta_\text{p})_z}\\
%r_{\text{L}} &=\frac{\Delta_{\text{L}}}{\Delta_{\text{p}}}\\
%r_{\text{R}} &=\frac{\Delta_{\text{R}}}{\Delta_{\text{p}}}
%\eea
%If the L/R node is a leaf, then we set
%\bea
%\Delta_{\text{L/R}}=\Delta_{\text{cut}}
%\eea



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%---------------------------------------------------------------------------------------
%\subsection{Other ideas for Toy Generative Models}
%
%We could define $\vec{\Delta}$, following the kinematics of a 2-body decay, as :
%\bea
% \vec{\Delta}   = E \sqrt{1-\frac{m^2}{E^2}} \,\,\,[ \hat{r} + (\gamma -1) (\hat{r} \cdot \hat{n}) \hat{n} ] = \vec{\Delta}(m,\phi)
%\eea
%
%We draw $\phi$ from a uniform distribution. We can get $m$ in a way to resemble the sudakov factor approach as:
%\beq\label{eq:drawMass}
%m_{\text{L}} = m_{\text{R}} = \frac{m_{\text{p}}}{2}\,\,  r 
%\eeq
%where $r_{\text{L/R}}$ is drawn from an exponential distribution as in (\ref{eq:exponential}) with $r \in [0,1)$. The prescription of (\ref{eq:drawMass}) solves one of the problems of the traditional parton showers given that it satisfies $m_{\text{L}} + m_{\text{R}} \leq m_{\text{p}}$\footnote{Traditional parton showers draw $m_{\text{L}}$ and $m_{\text{R}}$ independently, so they should check the constraint is satisfied.}. Then, we could think of $m_{\text{L/R}}$ as the off-shell mass value, to avoid the required reshuffling. This results in leaves where each pair of siblings have the same mass, all different among pairs of siblings.
%
%
%This case would be closer to a physics parton shower but more complex and time consuming.

%%-------------
%\subsubsection{General case, with  $m_{\text{L}}\neq m_{\text{R}}$}
%
%We could also build a model for this case, adding extra features. 
%We should replace (\ref{eq:drawMass}) by
%\bea
%m_{\text{L}} &= m_{\text{p}}\,\,  r_{\text{L}}  \\
%m_{\text{R}} &= (m_{\text{p}}-m_{\text{L}})\,\,  r_{\text{R}}
%\eea
%where $r_{\text{L}}$ and $r_{\text{R}}$ are independently drawn from an exponential distribution as in (\ref{eq:exponential}) for $r \in [0,1)$.
%

\section{Heuristic functions to implement $A^*$ on hierarchical clustering of Ginkgo Jets}
In this section we describe heuristic functions to set an upper bound on the log likelihood of Ginkgo jets. We want to minimize this upper bound, i.e. the closer it is to the exact maximum likelihood hierarchy the better.

\subsection{Basic heuristic functions}

% \paragraph{A- Inner nodes}
% \bea
%  f(t | \lambda, t_{\text{P}})=\frac{1}{1-e^{- \lambda}} \frac{\lambda}{t_{\text{P}}} e^{- \frac{\lambda}{ t_{\text{P}}} t} 
% \eea

% We maximize this function by taking $t \rightarrow 0$ and $t_{\text{P}} = t_{\text{cut}}$.

% \paragraph{B- Outer nodes}
% \bea
%  f(t | \lambda, t_{\text{P}})=\frac{1}{1-e^{- \lambda}} \bigg(1-e^{- \frac{\lambda}{ t_{\text{P}}} t_{\text{cut}}}\bigg) 
% \eea

% We maximize it by taking $t_{\text{Pi}} = \min_{\{j \neq i,\, j\, \text{in leaves}\}} t(p_i+p_j)$

% \subsection{Improved heuristic functions}

\subsubsection{ Inner nodes}
We want to find the smallest possible upper bound to 
\bea\label{inner_lh}
 f(t | \lambda, t_{\text{P}})=\frac{1}{1-e^{- \lambda}} \frac{\lambda}{t_{\text{P}}} e^{- \frac{\lambda}{ t_{\text{P}}} t} 
\eea

{\bf Basic bound:} We maximize this function by taking $t \rightarrow 0$ and $t_{\text{P}} = t_{\text{cut}}$.

{\bf Improved bound:}
We first focus on getting an upper bound for $ t_{\text{P}}$ in the exponential of eq. (\ref{inner_lh}). The upper bound for all the parent masses is given by the mass squared of the root vertex $t_{root}$ (vertex with all the elements). 

Next, we look for the biggest lower bound on $t$ in the exponential of eq. (\ref{inner_lh}).
We consider a fully unbalanced tree as the topology with the smallest values of $t$ per level and we bound each level in a bottom up approach (singletons are at the bottom).  For each inner vertex, the mass squared $t$ has to be greater than $t_{cut}$. Thus, for each element, we find the smallest parent invariant mass squared $t_{\text{Pi}}$ that is above the threshold $t_{cut}$, else set this value to $t_{cut}$ and save it to a list $t_{min}$. We sort this list and start a new list $t_{bound}$ with the first  $N//2$ entries of $t_{min}$ for the first level, where $N$ is the number of elements to cluster (this maximizes the number of possible nodes at the first level).
For the second level, we take $t_p^0$ as the minimum value in $t_{min}$ that is greater than $t_{cut}$ and bound the values by 
$[\tilde{t} *(i\%2)+ t_p^0*(i//2)] * (j// 2)$ for  $i = 3$ and $j = N \% 2 + N // 2$, where $\tilde{t}$ is the minimum element invariant mass squared. This is because $(j// 2)$ bounds the total number of nodes at current level and $i$ the minimum number of elements of a vertex at current level.
% For the second level, we take $\sum_{i=0}^3 t_i$ with $t_i$ the smallest three values for the invariant mass squared among all the elements. 
We calculate this bound level by level, maximizing the possible number of nodes at each level. This is described in Algorithm 2.


\begin{algorithm}
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}

    function lowerBound-$t$ $(t_i, t_{min}, N)$\\
    \Input{elements invariant mass squared: $t_i$, list with minimum parent mass squared for a pairing of two elements above $t_{cut}$: $t_{min}$, number of elements: $N$}
    \Indp
    $m^2= sort([t_i \text{ for i in elements}])$\\
    $t_{bound} = sort(t_{min})[0:N // 2]$\\
    i = 3\\
    $j = N \% 2 + N // 2$\\

    \While {$len(t_{bound}) < N - 2$}
         {  
        % $t_{bound} = \text{concatenate}(t_{bound}, [ sum(m^2[0:i])] * (j // 2))$\\
        $t_{bound} = \text{concatenate}(t_{bound}, [\tilde{t} *(i\%2)+ t_p^0*(i//2)] * (j// 2))$\\
        $j =  j \% 2 + j // 2 $\\
        $i += 1$
        }
    \Return $t_{bound}$
    \caption{Lower bound on $t$ in eq. (\ref{inner_lh})}
\end{algorithm}


Finally, to get a bound for $t_{\text{P}}$ in the denominator of eq. (\ref{inner_lh}) we want the minimum possible values. Thus we take $\tilde{t}_P = t_{bound}+ \tilde{t}$ (given that the parent of any inner node contains at least one more element) except when $t_{bound} < \text{max}\{t_i\}_{i=0}^N$ where we just keep $\tilde{t}_P =t_{bound}$ (see section \ref{Generatiion} for more details about the value of $t_P$).
% These are parents of inner nodes, so they have at least three elements. We use the following:
% \bea
% m_{a+c}^2 + m_{b}^2 < m_{a+c+b}^2 < 3 m_{a+c}^2 + m_{b}^2 < 3 (3 m_a^2+m_c^2) + + m_{b}^2
% \eea
Putting it all together, the upper bound for eq.  (\ref{inner_lh}) is
\bea
\sum \log f^{bound} = [-\log(1 - e^{- \lambda}) + \log(\lambda)] - \sum_{i=0}^{N-2} \bigg(\log(\tilde{t}_P ) + \lambda * \frac{t_{bound}^i }{ t_{root}} \bigg)
\eea


\subsubsection{ Outer nodes}
We want to find the smallest possible upper bound to 
\bea\label{outer_lh}
 f(t | \lambda, t_{\text{P}})=\frac{1}{1-e^{- \lambda}} \bigg(1-e^{- \frac{\lambda}{ t_{\text{P}}} t_{\text{cut}}}\bigg) 
\eea

{\bf Basic bound:} We maximize it by taking $t_{\text{Pi}} = \min_{\{j \neq i,\, j\, \text{in leaves}\}} t(p_i+p_j)$

{\bf Improved bound:}
We want the maximum possible value of  $t_{\text{P}}$ while still getting an upper bound in  eq. (\ref{outer_lh}).
A parent consists of a pairing of two elements (leaves). For each element, find the smallest parent invariant mass squared $t_{\text{Pi}}$ that is above the threshold $t_{cut}$, else set this mass to $t_{cut}$. We sort and save this list $t_{min}$.
We do not know the order in which the two children are sampled, the minimum value happens when each child is sampled last, $t_{\text{Pi}} \rightarrow (\sqrt{t_{\text{Pi}}} - \sqrt{t_i})^2$  (see section \ref{Generatiion} for more details). We take the minimum value greater than $t_{cut}$ in $t_{min}$ and refer to it as $t^0_{\text{Pi}}$. Thus we get  $t_{\text{Pi}} =  (\sqrt{t^0_{\text{Pi}}} - \sqrt{t_i})^2$. For the element with greatest invariant mass squared $t_i$ we just keep $t_{\text{Pi}} =t^0_{\text{Pi}}$.
Finally, sum the likelihood over each element $i$.


Below we plot in figure \ref{fig:bounds} both bounds on a dataset of  5000 Ginkgo jets.
\begin{figure*}
{
  \includegraphics[width=0.6\linewidth]{figs/UpperBoundsonLogLH_exact.pdf}
%  \includegraphics[width=0.5\linewidth]{plots/figTruthTruth_fullpath_jet2}
}
\caption{\small{We show a scatter plot for the values of the basic (black) and improved (color scale) bounds on 5000 Ginkgo jets. We can see that all values are above the diagonal.
}}
\label{fig:bounds}
\end{figure*}


% #################################################################################
\section{Joint likelihood}

We define the joint likelihood in Ginkgo as 
\begin{equation}\label{totalLH}
    p(\{p_i^\mu\}_{i=1}^N, \tau_k, N | \lambda) =  p(\{p_i^\mu\}_{i=1}^N| \tau_k , N, \lambda) \,\,\,\,p( \tau_k |N,\lambda)\,\,\,\ p(N |\lambda)
\end{equation}

with $\tau$ labeling a hierarchical clustering and $N$ the number of elements of the dataset (jet constituents).\footnote{ $p^\mu_L$ and $p^\mu_R$ are derived from momentum conservation (and a boost to the lab frame) given $t_P,\,\,t_L$ and $t_R$.} 

Given model parameters $\lambda$, $N$, and $\tau$ we have for the first term in eq. (\ref{totalLH})
\begin{equation}
 p(\{p_i^\mu\}_{i=1}^N| \tau_k , N, \lambda) = \frac{1}{Z}\,\, \tilde{p}(\{p_i^\mu\}_{i=1}^N| \tau_k , N, \lambda)
\end{equation}
with $Z$ the partition function and $\tilde{p}$ the unnormalized likelihood,
\begin{equation}
\tilde{p}(\{p_i^\mu\}_{i=1}^N| \tau_k , N, \lambda) \equiv \tilde{p}(x,z| \lambda) = \prod_j \tilde{p}(x_j|z_{\text{parent(xj)}},\lambda) \prod_i \tilde{p}(z_i| z_{\text{parent(zi)}}, \lambda)
\end{equation}
where $p(x_j|z_{\text{parent(xj)}},\lambda)$ are delta functions related to how we assign the available momentum values to the leaves of the tree, and 
% $\tilde{p}(z_i| z_{\text{parent(zi)}}, \lambda) \equiv \tilde{p}(x_j|z_{\text{parent(xj)}},\lambda)$ is given by eq. (\ref{splittingLH}) (and a constant $1/4 \pi$ to account for the solid angle, and
% And we have:
\begin{align}
    \tilde{p}(z_i| z_{\text{parent(zi)}}, \lambda) & \equiv p(t_L^i,t_R^i,\phi^i,\theta^i|t_p^i,\lambda) \nonumber \\ &=
    f(t_L^i | \lambda, t_{\text{P}}^i) \cdot f(t_R^i | \lambda, (\sqrt{t_{\text{P}}^i}-\sqrt{t_L^i})^2) \cdot \frac{1}{4 \pi}
\end{align}

For the likelihood of a hierarchy (including the assignment of the elements), second term in eq. (\ref{totalLH}), we get,
\begin{equation}
 p( \tau_k | N ) = \frac{1}{(2N-3)!!} 
\end{equation}

Finally we want to define the third term in eq. (\ref{totalLH}), $p(N |\lambda)$. Each time we sample a value $t > t_{cut}$ we add one element to the hierarchy because the new node in the tree is a non-leaf node. Thus, if we stop the showering process at some intermediate state we have,
\begin{eqnarray}
\tilde{p} (N+1 | \lambda, \{t_P^i\}_{i=1}^{N-1}) = \tilde{p} (N | \lambda, \{t_P^i\}_{i=1}^{N-1}) \frac{1}{N-1} \sum_{i=1}^{N-1} F(t_{cut} | \lambda, t_p^i)
\end{eqnarray}

with
\begin{eqnarray}
F(t_{cut} | \lambda, t_p^i) =
\left\{    
\begin{matrix}
\int_{t_{cut}}^{t_P^i} f(t| \lambda, t_P^i) dt \,\,\,\,\,\,\,\, &t_P^i>t_{cut}\\
0 \,\,\,\,\,\,\,\,& t_P^i \leq t_{cut} \\
\end{matrix}\right.
\end{eqnarray}

Thus we get
\begin{eqnarray}
\small{
\tilde{p} (N | \lambda, \{t_P^i\}_{i=1}^{N-2}) =
\left\{    
\begin{matrix}
1 \,\,\,\,\,\,\,\, & N=2\\
\prod_{n=3}^N \tilde{p}(n| \lambda,  \{t_P^i\}_{i=1}^{n-2})  = \prod_{n=3}^N  \frac{1}{n-2} \sum_{i=1}^{n-2} F(t_{cut} | \lambda, t_p^i) \,\,\,\,\,\,\,\, t_P^i \leq t_{cut}\,\,\,\,\,\,\,\, & N>2 \\
\end{matrix}\right.
}
\end{eqnarray}


Finally, marginalizing over $\{t_P^i\}$
\begin{eqnarray}
\tilde{p}(N|\lambda) = \int_{t_P^i} \tilde{p} (N | \lambda, \{t_P^i\}_{i=1}^{N-2}) 
\end{eqnarray}
with the constraint that for each pair of sibling nodes we require $\sqrt{t_P} > \sqrt{t_L} + \sqrt{t_R}$

Thus, the normalized likelihood is 
\begin{eqnarray}
p(N | \lambda) = \frac{1}{Z_N} \tilde{p}(N|\lambda)
\end{eqnarray}
with 
\begin{eqnarray}
Z_N = \sum_{N=2}^\infty  \tilde{p}(N|\lambda)
\end{eqnarray}
% #########
\subsubsection{ Likelihood of a particular topology}

We can also find the likelihood for a fixed tree structure, marginalizing over the assignment of the elements. In this case we have 
\begin{equation}
 p(\{p_i^\mu\}_{i=1}^N| \{\tau_k\}_{k=1}^m , N, \lambda) = \frac{1}{Z}\,\, \sum_{k=1}^m \tilde{p}(\{p_i^\mu\}_{i=1}^N| \tau_k , N, \lambda)
\end{equation}

where $\{\tau_k\}_{k=1}^m $ includes all the hierarchies with an identical structure. In this case we get
\begin{equation}
 p( \{\tau_k\}_{k=1}^m | N ) = \frac{1}{(2N-3)!!} \frac{N!}{2^k},
\end{equation}
here $k$ is defined as the number of permutations of the branches/sub-branches of a hierarchy that leave the topology invariant.



% There is also: $ P = p(\text{momentum}|\text{tree}) \cdot p(\text{tree})$.
% Here I would identify 
% \begin{align}
%     p(\text{momentum}|\text{tree}) = \prod_i p(t_L^i,p_R^i,\phi^i,\theta^i|t_p^i,\lambda)
% \end{align}
% and
% \begin{align}
% p(\text{tree}) = \frac{1}{\text{all possible trees}} \cdot (\text{all trees with same topology})
% \end{align}
% Finally, we would ask:
% \begin{align}
%     \int_{\text{constraint that respect the latent structure}} \prod_i p(t_L^i,p_R^i,\phi^i,\theta^i|t_p^i,\lambda) d\phi^i d\theta^i dt_L^i dt_R^i =1
% \end{align}

\bibliography{references}
\end{document}
